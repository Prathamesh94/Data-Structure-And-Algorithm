Problem Solving Round
A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer 
You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:
Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').
Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.
Input: answerKey = "TTFF", k = 2
Output: 4

maxcountT
maxcountF

2 + 2 = 4
2

“TTFF”



Input: answerKey = "TFFT", k = 1
Output: 3


F = 4
k=0


k=2

TTT F TTTT F TTT F TT F TT F TT
1 2 3 4 5 6 7 8 9  10 11 12 




1 2 3 4 5 6 7 8  9 F 

9


1 2 3 4 

1 2 3 0 4 5 6 6 6 7 8 9

0 0 0 1 1 1 1 1 1 2 3 3 3


Bruteforce: try all possible substring	































In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.
Return the maximum amount of gold you can collect under the conditions:
Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.


Input: grid = 0,6,0
         5,8,7
         0,9,0

Output: 24


/*In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.
Return the maximum amount of gold you can collect under the conditions:
Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.


Input: grid = 0,6,0
         5,8,7
         0,9,0

Output: 24
*/










let input = [[0,6,0],[5,8,7],[0,9,0]]
function getMaximumGold(goldGrid){
  let n = goldGrid.length
  let m = goldGrid[0].length
  let maxGold = 0
  for(let i=0;i<n;i++){
    for(let j=0;j<m;j++){

      if(goldGrid[i][j] != 0){
        let sum = 0
      
        dfs(i,j,goldGrid)
        
      }
      
    }
  }

  function dfs(row,col,grid){

    let delrow = [1,0,-1,0]
    let delcol = [0,1,0,-1]
    sum += grid[row][col]
    let grid[row][col]  =0
    let temp = grid[row][col]
    for(let i=0;i<4;i++){
      let nrow = row+delrow[i]
      let ncol = col+delcol[i]
      if(nrow >=0 && nrow <= n && ncol >=0 && ncol <= m){
        if(grid[nrow][ncol] != 0){
          dfs(nrow,ncol,grid)
          
          
        }
      }
      
    }
    maxGold = Math.max(sum,maxGold)
    grid[row][col] = temp
    sum -= grid[row][col]
    
  }
  
}
























You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.
Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.
 You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8


Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

