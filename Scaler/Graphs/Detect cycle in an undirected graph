//Link: https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=detect-cycle-in-an-undirected-graph
//Given an undirected graph with V vertices and E edges, check whether it contains any cycle or not. 
Solution:
//{ Driver Code Starts
// Initial Template for javascript
'use strict';

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', inputStdin => { inputString += inputStdin; });

process.stdin.on('end', _ => {
    inputString = inputString.trim().split('\n').map(
        string => { return string.trim(); });

    main();
});

function readLine() {
    return inputString[currentLine++];
}

function main() {
    let t = parseInt(readLine());
    for (let i = 0; i < t; i++) {
        let input_line = readLine().split(' ');
        let V = parseInt(input_line[0]);
        let E = parseInt(input_line[1]);

        let adj = new Array(V);
        for (let i = 0; i < V; i++) {
            adj[i] = new Array();
        }
        for (let i = 0; i < E; i++) {
            input_line = readLine().split(' ');
            let x = input_line[0];
            let y = input_line[1];
            adj[x].push(y);
            adj[y].push(x);
        }

        let obj = new Solution();
        let ans = obj.isCycle(V, adj);
        if (ans)
            ans = 1;
        else
            ans = 0;
        console.log(ans);
    }
}
// } Driver Code Ends


// User function Template for javascript

/**
 * @param {number} V
 * @param {number[][]} adj
 * @returns {boolean}
*/
class Solution {
    // Function to detect cycle in an undirected graph.
    isCycle(V, adj) {
        // code here
       
        let n = adj.length
        let visited = new Array(V).fill(-1)
        let obj = {
            visited :visited
        }
        for(let i=0;i<n;i++){
                    
            
            if(obj.visited[i] != 1){
               
               /*if(detectCycleBFS(i,obj,adj)){
                    return true
                }*/
                if(detectCycleDFS(i,obj,adj,-1)){
                    return true
                }
            }
            
        }
        return false
        function detectCycleDFS(node,obj,adj,parentNode){
            
            obj.visited[node] = 1
            //console.log(obj.visited,adj[node],parentNode,node)
            for(let i=0;i<adj[node].length;i++){
                
                if(obj.visited[adj[node][i]] == -1 && parentNode != adj[node][i] ){
                    
                    if (detectCycleDFS(adj[node][i],obj,adj,node)){
                        return true
                    }
                }else if(parentNode != adj[node][i] ){
                    return true
                }
            }
            return false
            
            
        }
        
        function detectCycleBFS(src,obj,adj){
            //console.log(src,obj.visited)
            obj.visited[src] = 1
            let queue = []
            queue.push([src,-1])
            
            while(queue.length != 0){
                let node = queue.shift()
                let parent = node[1]
                node = node[0]
                obj.visited[node] = 1
                //console.log(node,parent,adj[node],queue,visited)
                for(let i=0;i<adj[node].length ;i++){
                    
                    let adajenctnode = adj[node][i]
                    //console.log(visited,adajenctnode)
                    if(obj.visited[adajenctnode] != 1){
                        
                        queue.push([adajenctnode,node])
                    }else if(parent != adajenctnode){
                        return true
                        
                    }
                }
                
            }
            return false
            
            
            
        }
    }
}