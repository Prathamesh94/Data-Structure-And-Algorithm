Q1) Set Matrix Zeroes 


Q1) Set Matrix Zeroes : Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.

Answer:Loop 1: Iterate on array and copy index in hashmap if matrix[i][j] == 0
       Loop 2: Iterate on array if hashmap has i or j set element equal to 0
       
Code :
       var setZeroes = function(matrix) {
    
    let hashmap1 = {}
    let hashmap2 = {}
    
    for (let i =0 ;i<matrix.length;i++){
        for (let j =0 ;j<matrix[i].length;j++){
            if(matrix[i][j] == 0){
                hashmap1[i] = 'true'
                hashmap2[j] = 'true'   
            }
        
    }
    }
    for (let i =0 ;i<matrix.length;i++){
        for (let j =0 ;j<matrix[i].length;j++){
            if(hashmap1.hasOwnProperty(i) || hashmap2.hasOwnProperty(j)){
                matrix[i][j] = 0
            }
        
    }
    }
    return matrix
    
};
       
       
===========================================================================================================================================================

Q2)Pascal's Triangle : Given an integer numRows, return the first numRows of Pascal's triangle. chechk video

Answer:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
Code:
var generate = function(numRows) {
    let pascalT = []
    for(let i=0;i<numRows;i++){
        pascalT.push([])
        for(let j=0;j<i+1;j++){
            if(i<2 || j ==0 || j==i){
               pascalT[i].push(1)
               }else{
                   pascalT[i].push(pascalT[i-1][j-1]+pascalT[i-1][j])
               }
            
        
    }
    }
    return pascalT
    
};
       
       
===========================================================================================================================================================



Q3) Next Permutation : A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).

Example 1 :

Input format: Arr[] = {1,3,2}

Output: Arr[] = {2,1,3}

Explanation: All permutations of {1,2,3} are {{1,2,3} , {1,3,2}, {2,13} , {2,3,1} , {3,1,2} , {3,2,1}}. So, the next permutation just after {1,3,2} is {2,1,3}.



Answer:Loop 1: swapIndex1 => To find out break point from end of the array nums[i]>nums[i-1].  ::   if(nums[i]>nums[i-1]) => swapIndex1 = i-1.  
       Loop 2: swapIndex2 => To find out sightly greater number than nums[swapIndex1] on right side of breakpoint         ::   nums[i]>nums[swapIndex1]
       If there is no break point return reversed array as output no swapping required         ::   swapIndex1 == 0 && swapIndex2 == 0
       Else Swap numbers on SwapIndex1 and SwapIndex2  and reverse array from breakpoint       ::   Swap(nums,swapIndex1,swapIndex2)  reverse(nums,swapIndex1+1,nums.length-1)

Code:
   var nextPermutation = function(nums) {
    let swapIndex1 = 0
    let swapIndex2 = 0
    for (let i = nums.length; i >= 0; i--) {
        if (nums[i] > nums[i - 1]) {
            swapIndex1 = i - 1
            break
        }
    }
    for (let i = swapIndex1 + 1; i < nums.length; i++) {
        if (nums[swapIndex1] < nums[i]) {
            if (swapIndex2 == 0) {
                swapIndex2 = i
            }
            if (nums[swapIndex2] >= nums[i]) {
                swapIndex2 = i
            }
        }
    }
    //console.log(nums,swapIndex1,swapIndex2)
    if (swapIndex1 != 0 || swapIndex2 != 0) {
        nums = swap(nums, swapIndex1, swapIndex2)
        if (nums.length - 1 - swapIndex1 > 2) {
            nums = reverse(nums, swapIndex1 + 1, nums.length - 1)
            console.log(nums, swapIndex1)
        } else {
            if (nums[swapIndex1 + 1] > nums[swapIndex1 + 2]) {
                nums = swap(nums, swapIndex1 + 1, swapIndex1 + 2)
            }
        }

    } else {
        nums = reverse1(nums, swapIndex1, nums.length - 1)
    }
    return nums
};



=====================================================================================================================================================
Q4)Kadane’s Algorithm : Maximum Subarray Sum in an Array
Problem Statement: Given an integer array arr, find the contiguous subarray (containing at least one number) which
has the largest sum and return its sum and print the subarray.

Code:
var maxSubArray = function(nums) {
    let sum = nums[0]
    let max = nums[0]
    if (nums.length == 1) {
        return sum
    }
    for (let i = 1; i < nums.length; i++) {
        if (sum < 0) {
            sum = 0
        }
        sum = sum + nums[i]
        if (max < sum) {
            max = sum
        }
    }
    return max

};


=====================================================================================================================================================

       
Q5)Sort an array of 0’s 1’s 2’s
 Intuition: In this approach, we will be using 3 pointers named low, mid, and high. We will be using these 3 pointers to move around the values. The primary goal here is to move 0s to the left and 2s to the right of the array and at the same time all the 1s shall be in the middle region of the array and hence the array will be sorted. 
 Answer: Initiate low mid with zero and high with n-1
         Switch case 0) nums = swap(nums,mid,low);
                        low = low +1;
                        mid = mid +1
                case 1) mid = mid +1
                case 2) nums = swap(nums,mid,high)
                        high = high -1
                        
                        

===========================================================================================================================================================
Q6) Stock Buy And Sell : You are given an array of prices where prices[i] is the price of a given stock on an ith day.

    var maxProfit = function(prices) {
    let maxProfit = 0
    let profit = 0
    for(let i=0;i<prices.length-1;i++){
            profit = profit + prices[i+1]-prices[i]
            if(profit > maxProfit){
                maxProfit = profit                
            }
        if(profit < 0){
            profit = 0
        }
    }
    return maxProfit  
};
                        
                        

===========================================================================================================================================================

                       
Q7) Rotate Matrix : You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

Answer: Loop1: Transver Matrix rows replace columns ,columns replace rows
        Loop2: Reverse Matrix
        
Code:
function transverseSwap(matrix,i,j){
    //console.log(matrix,i,j)
    let temp = matrix[i][j]
    matrix[i][j] = matrix[j][i]
    matrix[j][i] = temp
    //console.log(matrix)
    return matrix
}

function swap(arr,i,j){
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
    return arr
    
}

function reverse(arr,i,j){
    while(i<j){
        swap(arr,i,j)
        i +=1
        j -=1
    }
    return arr
}
var rotate = function(matrix) {
    
    for(let i=0;i<matrix.length;i++){
        for(let j=0;j<i;j++){
           matrix = transverseSwap(matrix,i,j)
        
    }   
    }
    for(let i=0;i<matrix.length;i++){
        matrix[i] = reverse(matrix[i],0,matrix[i].length-1)
    }
    
    return matrix
};
        
===========================================================================================================================================================

    

Q8)Merge Overlapping Sub-intervals : Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

Code:
var merge = function(intervals) {
    let i = 0
    intervals.sort(function(a, b) {
        return a[0] - b[0]
    })
    let intervalsout = [intervals[0]]
    if (intervals.length == 1) {
        return intervals
    }
    while (i < intervals.length) {
        if (intervalsout[intervalsout.length - 1][1] >= intervals[i][0]) {
            if (intervalsout[intervalsout.length - 1][1] <= intervals[i][1]) {
                intervalsout[intervalsout.length - 1][1] = intervals[i][1]
            }
        } else {
            intervalsout.push(intervals[i])

        }
        i += 1
    }
    return intervalsout
};



===========================================================================================================================================================


 Q9)Merge two Sorted Arrays Without Extra Space : Problem statement: Given two sorted arrays arr1[] and arr2[] of sizes n and m in non-decreasing order. Merge them in sorted order. Modify arr1 so that it contains the first N elements and modify arr2 so that it contains the last M elements.
 
 var merge = function(nums1, m, nums2, n) {
    while(nums1.length >m){
            nums1.pop()  
        }
    while(nums2.length >n){
            nums2.pop()
            
        }
    for(let i=0;i<nums1.length;i++){
       //
        if(nums1[i] > nums2[0]){
            nums1,nums2 = swap(nums1,nums2,i)
            nums2.sort(function(a,b){return a-b})
        }
    }
     for(let i=0;i<n;i++){
            nums1.push(nums2[i])
     }
};


===========================================================================================================================================================

    

Q10) Find the Duplicate Number:Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.

Answer:
Solve using hashmap

===========================================================================================================================================================

Q11) Repeat and Missing Number Array : You are given a read only array of n integers from 1 to n.
Each integer appears exactly once except A which appears twice and B which is missing.
Return A and B.
Code:

repeatedNumber: function(A) {
    let output = []
    let hashmap = {}
    for (let i = 0; i < A.length; i++) {
        if (hashmap.hasOwnProperty(A[i])) {
            output.push(A[i])
        }
        hashmap[A[i]] = i
    }
    for (let i = 1; i <= A.length; i++) {
        if (!hashmap.hasOwnProperty(i)) {
            output.push(i)
            break;
        }

    }
    return output
}


===========================================================================================================================================================

Q12)Count inversions in an array : Given an array of N integers, count the inversion of the array (using merge-sort).

What is an inversion of an array? Definition: for all i & j < size of array, if i < j then you have to find pair (A[i],A[j]) such that A[j] < A[i].
    


===========================================================================================================================================================


Q13)Search in a sorted 2D matrix : Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.


Code:
var searchMatrix = function(matrix, target) {
    if (matrix.length ==1 && matrix[0].length ==1 && matrix[0][0] == target){
        return true
    }
    for(let i=0;i<matrix.length;i++){
        if(matrix[i][matrix[i].length-1] >= target){
           let low =0
           let high =matrix[i].length-1
           let mid = Math.floor((high-low)/2)
           console.log(mid,high,low)
           while(low <= high){
               mid =low+ Math.floor((high-low)/2)
               if(target == matrix[i][mid]){ //mid % matrix[0].size()
                  return true
                  }
               else if(target > matrix[i][mid]){
                  low = low + 1
                   
                  
                  }
               else {
                   high = high - 1 
               }
              
               console.log(mid,high,low)
                 
                 }
           }
    }
    return false
    
};
    
    
    

===========================================================================================================================================================



Q14)Pow(x, n) : Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000

Code:

var myPow = function(x, n) {
    let output =x
    if(Math.abs(n) > 0 && Math.abs(x) != 1){
        for(let i=1;i<Math.abs(n);i++){
        output = output*x
    }
        
    }else if(Math.abs(n)  == 0){
        output =1
             
             }
    
    if(x == -1 && n%2 == 0){
        output = 1
    }else if(x == -1 && n%2 != 0){
         output = -1
    }
    if(n>= 0){
        return output
    }else{
        return 1/output
        
    }
    
};



    
===========================================================================================================================================================



Q15) Majority Element : Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

Answer:
Intuition: The question clearly states that the nums array has a majority element. Since it has a majority element we can say definitely the count is more than N/2.

Code:
var majorityElement = function(nums) {
    let count = 0
    let candidate = 0
    for(let i=0;i<nums.length;i++){
        if(count == 0){
            candidate = nums[i]
           }
        
        if(nums[i] == candidate){
            count += 1
        }else{
            count -= 1
        }
    }
    return candidate
    
    
};




    
===========================================================================================================================================================


Q16)Majority Element II : Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Answer:
Approach + Intuition: In our code, we start with declaring a few variables:

num1 and num2 will store our currently most frequent and second most frequent element.
c1 and c2 will store their frequency relatively to other numbers.
We are sure that there will be a max of 2 elements which occurs > N/3 times because there cannot be if you do a simple math addition.

Code:
var majorityElement = function(nums) {
    let count1 = 0
    let count2 = 0
    let candidate1 = -1
    let candidate2 = -1
    let candidates = []
   // console.log(candidate1,candidate2,count1,count2)
    for(let i=0;i<nums.length;i++){
        console.log(candidate1,candidate2,count1,count2)
        if (nums[i] == candidate1){
            count1 += 1
        }else if (nums[i] == candidate2){
            count2 += 1
        } else if(count1 == 0){
            candidate1 = nums[i]
            count1 = 1
           } else if(count2 == 0){
            candidate2 = nums[i]
             count2 = 1
           } else{
               console.log('hellow')
               count1 -= 1
               count2 -= 1
           }
        console.log(candidate1,candidate2,count1,count2)
    }
        
        count1= 0
    count2 =0
    console.log(candidate1,candidate2,count1,count2)
    for(let i=0;i<nums.length;i++){
        if (nums[i] == candidate1){
            count1 += 1
        }else if (nums[i] == candidate2){
            count2 += 1
        }
    }
        console.log(count1,count2,nums.length/3)
        if(count1 > nums.length/3){
            candidates.push(candidate1)
        }
        if(count2 >nums.length/3){
            candidates.push(candidate2)
        }
    return candidates
    
    
};


    
===========================================================================================================================================================



Q17)Grid Unique Paths : There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.


Code:

function possiblePath(i,j,m,n,hashmap){
    if(!hashmap.hasOwnProperty(i)){
        hashmap[i] = {}
    }
   // console.log(hashmap)
    if(i == m-1 && j == n-1){
        return 1
       }
    if(i>=m || j>=n){
        return 0
        }else if(hashmap.hasOwnProperty(i) && hashmap[i].hasOwnProperty(j)){
            return hashmap[i][j]
        }
        else{
            return hashmap[i][j] = possiblePath(i+1,j,m,n,hashmap) + possiblePath(i,j+1,m,n,hashmap)
        }
    
    
}
var uniquePaths = function(m, n) {
    
    /*let hashmap = {}
    return possiblePath(0,0,m,n,hashmap)*/
    let N = m+n-2
    let r = m-1
    let res =1
    
    for(let i=1;i<=r;i++){
        
        res =res*((N-r+i)/i)
    }
    return res
};





    
===========================================================================================================================================================



Q18)Reverse Pairs : Given an integer array nums, return the number of reverse pairs in the array.

A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j].

Code:


    
===========================================================================================================================================================




Q19)2-Sum-Problem : Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Code:

var twoSum = function(nums, target) {
    let hashmap ={}
    for(let i=0;i<nums.length;i++){
        if(hashmap.hasOwnProperty(target-nums[i])){
            return [hashmap[target-nums[i]],i]
        } else{
            hashmap[nums[i]] = i
        }
    }
    
};



    
===========================================================================================================================================================


Q20)4Sum : Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

Intuition: In the previous approach we fixed three-pointers and did a binary search to find the fourth. Over here we will fix two-pointers and then find the remaining two elements using two pointer technique as the array will be sorted at first.

Approach: Sort the array, and then fix two pointers, so the remaining sum will be (target – (nums[i] + nums[j])). Now we can fix two pointers, one front, and another back, and easily use a two-pointer to find the remaining two numbers of the quad. In order to avoid duplications, we jump the duplicates, because taking duplicates will result in repeating quads. We can easily jump duplicates, by skipping the same elements by running a loop.

Code:

var fourSum = function(nums, target) {
    
    nums.sort(function(a,b){return a-b})
    //console.log(nums)
    let quadruplets = []
    let hashmap = {}
    for(let i=0;i<nums.length;i++){
        for(let j=i+1;j<nums.length;j++){
            let twosum = target-nums[j]-nums[i]
            let low = j+1
            let high = nums.length-1
            while(low<high){
                let sum = nums[low] + nums[high]
                if (sum > twosum) {
                    high = high-1
                    }
                else if (sum < twosum){
                    low =low +1         
                } else {
                    let string = `${nums[i]},${nums[j]},${nums[low]},${nums[high]}`
                    /*if(!hashmap.hasOwnProperty(string)){
                        quadruplets.push([nums[i],nums[j],nums[low],nums[high]])
                        hashmap[string] = "true"
                    }*/
                    let quad = [nums[i],nums[j],nums[low],nums[high]]
                    quadruplets.push(quad)
                   while(low < high && quad[2] == nums[low]) { low += 1 }
                    while(low<high && quad[3] == nums[high]){ high -= 1 } 
                }
            }
           while(j + 1 < nums.length && nums[j + 1] == nums[j]) ++j;
            
        }
        while(i + 1 < nums.length && nums[i + 1] == nums[i]) ++i;
        
    } 
    return quadruplets
   
    
};




    
===========================================================================================================================================================


    
    
  Q21)Longest Consecutive Sequence : Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

var longestConsecutive = function(nums) {
    
        const sortedNums = [...new Set(nums.sort((a, b) => a - b))]
    const sortedNumsLen = sortedNums.length
    let ctr = 0
    const cont = []
    
    if (sortedNumsLen === 0) {
        return sortedNumsLen
    }

    for (let i = 1; i < sortedNumsLen; i++) {
    	if ((sortedNums[i] - sortedNums[i - 1]) === 1) {
      	ctr++
      } else {
      	cont.push(ctr + 1)
        ctr = 0
      }
    }

    return Math.max(...cont, ctr + 1)
    
};



    
===========================================================================================================================================================


   

Q22) Largest Subarray with 0 sum : Given an array having both positive and negative integers. The task is to compute the length of the largest subarray with sum 0.

Code:
maxLen(arr, n) {
    //code here
    let hashmap = {}
    let sum = 0
    let max = 0
    for (let i = 0; i < n; i++) {
        sum = sum + arr[i]
        //console.log(hashmap)
        if (sum == 0) {
            max = i + 1
        } else {
            if (hashmap.hasOwnProperty(sum)) {
                if (max < i - hashmap[sum]) {

                    max = i - hashmap[sum]
                }
            } else {
                hashmap[sum] = i
            }
        }
    }
    return max
}




    
===========================================================================================================================================================

Q23)Count number of subarrays with given Xor K : Given an array of integers A and an integer B.

Find the total number of subarrays having bitwise XOR of all elements equals to B.

Code: 

solve: function(A, B) {
    let prefix = {}
    let xor = 0
    let count = 0
    for (let i = 0; i < A.length; i++) {
        xor = xor ^ A[i]
        if (xor == B) {
            count += 1
        }
        if (prefix.hasOwnProperty(xor ^ B)) {
            count += prefix[xor ^ B]
        }
        if (prefix.hasOwnProperty(xor)) {

            prefix[xor] = prefix[xor] + 1
        } else {
            prefix[xor] = 1
        }
    }
    return count
}   
   
   


    
===========================================================================================================================================================
Q24)Longest Substring Without Repeating Characters : Given a string s, find the length of the longest substring without repeating characters.



   
   
   
   


    
===========================================================================================================================================================

Q25) Reverse a Linked List : Given the head of a singly linked list, write a program to reverse the linked list, and return the head pointer to the reversed list.
   
   Code:
   var reverseList = function(head) {
    let prev =null
    let next = null
    let current = head
     while(current != null){
         
         next = current.next
         current.next = prev
         prev = current
         current = next
         
     }
    head = prev
    return head
};
   


    
===========================================================================================================================================================

Q26)Middle of the Linked List :  Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

Intuition: In the Tortoise-Hare approach, we increment slow ptr by 1 and fast ptr by 2, so if take a close look fast ptr will travel double than that of the slow pointer. So when the fast ptr will be at the end of Linked List, slow ptr would have covered half of Linked List till then. So slow ptr will be pointing towards the middle of Linked List.

Code: 
var middleNode = function(head) {
    let slow = head
    let fast =head
    
    while(fast && fast.next){
        
        slow = slow.next
        fast = fast.next.next
          
          }
    return slow
};

   


    
===========================================================================================================================================================


Q27)Merge Two Sorted Lists : You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

Code:
function ListNode(val) {
      this.val = val;
       this.next = null;
}
var mergeTwoLists = function(list1, list2) {
    let dummyHead = new ListNode(0);
    let currentNode = dummyHead; 
    while(list1 !== null && list2 !== null){

        if(list1.val < list2.val){
            currentNode.next = list1;
            list1 = list1.next
        } else {
            currentNode.next = list2
            list2 = list2.next
        }

        currentNode = currentNode.next
    }

    if(list1 !== null) {
        currentNode.next = list1;
    } else if (list2 !== null) {
        currentNode.next = list2
    }

    return dummyHead.next
    
};



    
===========================================================================================================================================================


Q28)Remove Nth Node From End of List : Given the head of a linked list, remove the nth node from the end of the list and return its head.


Code:
var removeNthFromEnd = function(head, n) {
    let start = head
    let current = head
    let next = null
    let prev = null
    while(current != null){
        next = current.next
        current.next = prev
        prev = current
        current = next
          }
    head = prev
    current = prev
    next = null
    prev = null
    let m = 1
   while(current != null){
    if(n==m){
        next = current.next
        current = next
       }
       if(current != null){
        next = current.next
        current.next = prev
        prev = current
        current = next   
       }
       m += 1
    }
    return prev
};






    
===========================================================================================================================================================


Q29)Add Two Numbers : You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.








    
===========================================================================================================================================================
Q30) Delete Node in a Linked List : Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.

It is guaranteed that the node to be deleted is not a tail node in the list.

Code: 
var deleteNode = function(node) {
    node.val = node.next.val
    node.next = node.next.next
};







    
===========================================================================================================================================================
Q31)Find intersection point of Y LinkedList : Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.

var getIntersectionNode = function(headA, headB) {
    if(headA===null || headB===null) {
        return null;
    }
    let r1=headA;
    let r2=headB;
    while(r1!==r2){
        r1=r1.next;
        r2=r2.next;
        if(r1===r2){
           return r1;
        }
        if (r1===null){
          r1=headB;  
        }
        if(r2===null){
            r2=headA;
        }
    }
    return r1;
};






    
===========================================================================================================================================================

Q32)Detect a cycle in Linked List :

var hasCycle = function(head) {
    let fast = head;
  while (fast && fast.next) {
    head = head.next;
    fast = fast.next.next;
    if (head === fast) return true;
  }
  return false;
    
};


    
===========================================================================================================================================================

Q33)Reverse a LinkedList in groups of size k.








    
===========================================================================================================================================================

Q34)Palindrome Linked List : Given the head of a singly linked list, return true if it is a palindrome.

Answer:

1) Slow fast to find middle
2) reverse linked list
3) compare slow and head string


var isPalindrome = function(head) {
    
   function findMiddle(fast, slow) {
        if(!fast || !fast.next) return slow;
        return findMiddle(fast.next.next, slow.next);
    }
    
    function reverse(node, prev) {
        if(!node) return prev;
        const next = node.next;
        node.next = prev;
        return reverse(next, node);
    }
    
    const mid = findMiddle(head, head);
    const revMid = reverse(mid, null);
    
    function traverse(n1, n2) {
        if(!n1 || !n2) return true;
        if(n1.val !== n2.val) return false;
        return traverse(n1.next, n2.next);
    }
    return traverse(head, revMid);
};






    
===========================================================================================================================================================

    
    
    
 Q35)Find the starting point of the Loop of LinkedList : Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.

Do not modify the linked list.

Answer:
"To summarize, we move FastPointer twice as fast as SlowPointer. When SlowPointer enters the loop, after k nodes, FastPointer is k nodes into the loop. This means that FastPointer and SlowPointer are LOOP_SIZE - k nodes away from each other.
Next, if FastPointer moves two nodes for each node that SlowPointer moves, they move one node closer to each other on each turn. Therefore, they will meet after LOOP_SIZE - k turns. Both will be k nodes from the front of the loop.
The head of the linked list is also k nodes from the front of the loop. So, if we keep one pointer where it is, and move the other pointer to the head of the linked list. then they will meet at the front of the loop."
    
    
     
 Code:
 
 var detectCycle = function(head) {
    let slow = head;
    let fast = head;
    while (slow && fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow === fast) {
            while (head !== fast) {
                head = head.next;
                fast = fast.next;
            }
            return head;
        }
    }
    return null;
};
